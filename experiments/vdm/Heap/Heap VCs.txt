Parsed 7 modules in 0.232 secs. No syntax errors
Type checked 7 modules in 0.042 secs. No type errors
Generated 124 proof obligations:

Proof Obligation 1: (Unproved)
min: let be st existence obligation in 'Heap4' (./Heap4.vdmsl) at line 25:13
(forall ss:set of (nat) & (ss <> {}) =>
  exists x in set ss)

Proof Obligation 2: (Unproved)
min, y: function apply obligation in 'Heap4' (./Heap4.vdmsl) at line 26:21
(forall ss:set of (nat) & (ss <> {}) =>
  (forall x in set ss &
    pre_min((ss \ {x}))))

Proof Obligation 3: (Unproved)
min, y: recursive function obligation in 'Heap4' (./Heap4.vdmsl) at line 23:5
(forall ss:set of (nat) & (ss <> {}) =>
  (forall x in set ss &
    measure_min(ss) > measure_min((ss \ {x}))))

Proof Obligation 4: (Unproved)
remove4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 36:13
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  curr in set dom store)

Proof Obligation 5: (Unproved)
remove4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 36:19
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  ((((is_nat(curr))))))

Proof Obligation 6: (Unproved)
remove4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 36:34
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not (store(curr) < n) =>
    curr in set dom store))

Proof Obligation 7: (Unproved)
remove4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 36:40
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not (store(curr) < n) =>
    ((((is_nat(curr)))))))

Proof Obligation 8: (Unproved)
remove4: recursive function obligation in 'Heap4' (./Heap4.vdmsl) at line 34:5
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (((store(curr) < n) or (store(curr) = (n + 1))) =>
    measure_LocLocStoreNat1(prev, curr, store, n) > measure_LocLocStoreNat1(curr, store((curr + 1)), store, n)))

Proof Obligation 9: (Unproved)
remove4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 37:27
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (((store(curr) < n) or (store(curr) = (n + 1))) =>
    (curr + 1) in set dom store))

Proof Obligation 10: (Unproved)
remove4, store1: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 39:30
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    curr in set dom store))

Proof Obligation 11: (Unproved)
remove4, store1: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 39:36
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    ((((is_nat(curr)))))))

Proof Obligation 12: (Unproved)
remove4, store1: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 43:55
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    ((store(curr) = n) =>
      (not (prev = nil) =>
        (curr + 1) in set dom store))))

Proof Obligation 13: (Unproved)
remove4, store1: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 45:49
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    (not (store(curr) = n) =>
      curr in set dom store)))

Proof Obligation 14: (Unproved)
remove4, store1: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 45:55
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    (not (store(curr) = n) =>
      ((((is_nat(curr))))))))

Proof Obligation 15: (Unproved)
remove4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 46:45
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    (let store1:(Store | map ((Loc | [Loc])) to (([nat] | int)) | map ((Loc | nat1)) to ([nat])) = (if (store(curr) = n)
    then (if (prev = nil)
    then store
    else (store ++ {(prev + 1) |-> store((curr + 1))}))
    else (store ++ {curr |-> (store(curr) - n)})) in
      curr in set dom store)))

Proof Obligation 16: (Unproved)
remove4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 46:51
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    (let store1:(Store | map ((Loc | [Loc])) to (([nat] | int)) | map ((Loc | nat1)) to ([nat])) = (if (store(curr) = n)
    then (if (prev = nil)
    then store
    else (store ++ {(prev + 1) |-> store((curr + 1))}))
    else (store ++ {curr |-> (store(curr) - n)})) in
      ((((is_nat(curr))))))))

Proof Obligation 17: (Unproved)
remove4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 46:56
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  (not ((store(curr) < n) or (store(curr) = (n + 1))) =>
    (let store1:(Store | map ((Loc | [Loc])) to (([nat] | int)) | map ((Loc | nat1)) to ([nat])) = (if (store(curr) = n)
    then (if (prev = nil)
    then store
    else (store ++ {(prev + 1) |-> store((curr + 1))}))
    else (store ++ {curr |-> (store(curr) - n)})) in
      ((is_nat(((curr + store(curr)) - n)))))))

Proof Obligation 18: (Unproved)
remove4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 34:5
(forall prev:[Loc], curr:[Loc], store:Store, n:nat1 &
  is_((if ((store(curr) < n) or (store(curr) = (n + 1)))
  then remove4(curr, store((curr + 1)), store, n)
  else let store1:(Store | map ((Loc | [Loc])) to (([nat] | int)) | map ((Loc | nat1)) to ([nat])) = (if (store(curr) = n)
  then (if (prev = nil)
  then store
  else (store ++ {(prev + 1) |-> store((curr + 1))}))
  else (store ++ {curr |-> (store(curr) - n)})) in mk_(store1, mk_Piece(((curr + store(curr)) - n), n))), (Store * Piece)))

Proof Obligation 19: (Unproved)
insert4: function apply obligation in 'Heap4' (./Heap4.vdmsl) at line 52:13
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (((curr <> nil) and (a > curr)) =>
    pre_insert4(curr, store((curr + 1)), store, a, s)))

Proof Obligation 20: (Unproved)
insert4: recursive function obligation in 'Heap4' (./Heap4.vdmsl) at line 49:5
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (((curr <> nil) and (a > curr)) =>
    measure_LocLocStoreLocNat1(prev, curr, store, a, s) > measure_LocLocStoreLocNat1(curr, store((curr + 1)), store, a, s)))

Proof Obligation 21: (Unproved)
insert4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 52:27
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (((curr <> nil) and (a > curr)) =>
    (curr + 1) in set dom store))

Proof Obligation 22: (Unproved)
insert4, store1: map sequence compatible obligation in 'Heap4' (./Heap4.vdmsl) at line 54:35
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    forall m1, m2 in set {{a |-> s}, {(a + 1) |-> curr}} &
      forall d3 in set dom m1, d4 in set dom m2 &
        d3 = d4 => m1(d3) = m2(d4)))

Proof Obligation 23: (Unproved)
insert4, store3: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 63:55
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (not ((curr = nil) or ((a + s) < curr)) =>
          is_real(store2(curr)))))))

Proof Obligation 24: (Unproved)
insert4, store3: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 63:55
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (not ((curr = nil) or ((a + s) < curr)) =>
          curr in set dom store2)))))

Proof Obligation 25: (Unproved)
insert4, store3: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 63:62
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (not ((curr = nil) or ((a + s) < curr)) =>
          (is_(curr, Loc) and ((((is_nat(curr)))))) or
          (is_(curr, Loc) and (((((is_nat(curr))))))) or
          (is_(curr, nat1) and is_nat1(curr)))))))

Proof Obligation 26: (Unproved)
insert4, store3: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 64:51
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (not ((curr = nil) or ((a + s) < curr)) =>
          (curr + 1) in set dom store2)))))

Proof Obligation 27: (Unproved)
insert4, store3: map sequence compatible obligation in 'Heap4' (./Heap4.vdmsl) at line 63:41
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (not ((curr = nil) or ((a + s) < curr)) =>
          forall m1, m2 in set {{a |-> (s + store2(curr))}, {(a + 1) |-> store2((curr + 1))}} &
            forall d3 in set dom m1, d4 in set dom m2 &
              d3 = d4 => m1(d3) = m2(d4))))))

Proof Obligation 28: (Unproved)
insert4, store4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 65:62
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not (prev = nil) =>
            prev in set dom store))))))

Proof Obligation 29: (Unproved)
insert4, store4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 65:68
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not (prev = nil) =>
            ((((is_nat(prev)))))))))))

Proof Obligation 30: (Unproved)
insert4, store4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 69:57
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            is_real(store3(prev))))))))

Proof Obligation 31: (Unproved)
insert4, store4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 69:72
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            is_real(store3(a))))))))

Proof Obligation 32: (Unproved)
insert4, store4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 69:57
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            prev in set dom store3))))))

Proof Obligation 33: (Unproved)
insert4, store4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 69:64
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            (is_(prev, Loc) and ((((is_nat(prev)))))) or
            (is_(prev, Loc) and (((((is_nat(prev))))))) or
            (is_(prev, nat1) and is_nat1(prev))))))))

Proof Obligation 34: (Unproved)
insert4, store4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 69:72
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            a in set dom store3))))))

Proof Obligation 35: (Unproved)
insert4, store4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 70:59
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            (a + 1) in set dom store3))))))

Proof Obligation 36: (Unproved)
insert4, store4: map sequence compatible obligation in 'Heap4' (./Heap4.vdmsl) at line 69:45
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  (not ((curr <> nil) and (a > curr)) =>
    (let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in
      (let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
      then store1
      else (store1 ++ {(prev + 1) |-> a})) in
        (let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
        then store2
        else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in
          (not ((prev = nil) or ((prev + store(prev)) < a)) =>
            forall m1, m2 in set {{prev |-> (store3(prev) + store3(a))}, {(prev + 1) |-> store3((a + 1))}} &
              forall d3 in set dom m1, d4 in set dom m2 &
                d3 = d4 => m1(d3) = m2(d4)))))))

Proof Obligation 37: (Unproved)
insert4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 49:5
(forall prev:[Loc], curr:[Loc], store:Store, a:Loc, s:nat1 & ((s > 1) and (((prev = nil) or ((curr = nil) or (prev < curr))) and (Heap3isOk3(prev, store) and Heap3isOk3(curr, store)))) =>
  ((is_((if ((curr <> nil) and (a > curr))
  then insert4(curr, store((curr + 1)), store, a, s)
  else let store1:map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1)) = (store ++ {a |-> s, (a + 1) |-> curr}) in let store2:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if (prev = nil)
  then store1
  else (store1 ++ {(prev + 1) |-> a})) in let store3:(map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((curr = nil) or ((a + s) < curr))
  then store2
  else (({curr, (curr + 1)} <-: store2) ++ {a |-> (s + store2(curr)), (a + 1) |-> store2((curr + 1))})) in let store4:(map ((Loc | Loc | [Loc] | nat1)) to ((Loc | [Loc] | [nat] | nat)) | map ((Loc | Loc | nat1)) to ((Loc | [Loc] | [nat] | nat1)) | map ((Loc | Loc | nat1)) to (([Loc] | [nat] | nat1))) = (if ((prev = nil) or ((prev + store(prev)) < a))
  then store3
  else (({a, (a + 1)} <-: store3) ++ {prev |-> (store3(prev) + store3(a)), (prev + 1) |-> store3((a + 1))})) in store4), map (Loc) to ([nat])))))

Proof Obligation 38: (Unproved)
NEW4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 97:22
((req > 1) =>
  (let mk_(start, store):Free3 = free4 in
    (forall a in set (dom store) &
      a in set dom store)))

Proof Obligation 39: (Unproved)
NEW4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 98:23
((req > 1) =>
  (let mk_(start, store):Free3 = free4 in
    (forall a in set (dom store) &
      ((store(a) <> nil) =>
        a in set dom store))))

Proof Obligation 40: (Unproved)
NEW4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 98:41
((req > 1) =>
  (let mk_(start, store):Free3 = free4 in
    (forall a in set (dom store) &
      ((store(a) <> nil) =>
        (not (store(a) = req) =>
          a in set dom store)))))

Proof Obligation 41: (Unproved)
NEW4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 102:34
(let mk_(startA, storeA):Free3 = free4 in
  (let mk_(startB, storeB):Free3 = free4~ in
    startB in set dom storeA))

Proof Obligation 42: (Unproved)
NEW4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 102:41
(let mk_(startA, storeA):Free3 = free4 in
  (let mk_(startB, storeB):Free3 = free4~ in
    ((((is_nat(startB)))))))

Proof Obligation 43: (Unproved)
NEW4: map apply obligation in 'Heap4' (./Heap4.vdmsl) at line 103:33
(let mk_(startA, storeA):Free3 = free4 in
  (let mk_(startB, storeB):Free3 = free4~ in
    ((storeA(startB) = req) =>
      (startB + 1) in set dom storeA)))

Proof Obligation 44: (Unproved)
NEW4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 106:69
(let mk_(startA, storeA):Free3 = free4 in
  (let mk_(startB, storeB):Free3 = free4~ in
    ((startA = (if (storeA(startB) = req)
    then storeA((startB + 1))
    else startB)) =>
      req > 0)))

Proof Obligation 45: (Unproved)
NEW4: operation post condition obligation in 'Heap4' (./Heap4.vdmsl) at line 92:5
let mk_(startA, storeA):Free3 = free4 in let mk_(startB, storeB):Free3 = free4~ in ((startA = (if (storeA(startB) = req)
then storeA((startB + 1))
else startB)) and (mk_(storeA, res) = remove4(nil, startB, storeB, req)))

Proof Obligation 46: (Unproved)
NEW4: operation satifiability obligation in 'Heap4' (./Heap4.vdmsl) at line 92:5
(forall req:nat, oldstate:StateName &
  pre_NEW4(req, oldstate) =>
  exists res:Piece, newstate:StateName & post_NEW4(req, res, oldstate, newstate))

Proof Obligation 47: (Unproved)
DISPOSE4: function apply obligation in 'Heap4' (./Heap4.vdmsl) at line 112:41
(((ret.SIZE) > 1) =>
  (let mk_(start, store):Free3 = free4 in
    pre_locs3(start, store)))

Proof Obligation 48: (Unproved)
DISPOSE4: function apply obligation in 'Heap4' (./Heap4.vdmsl) at line 119:37
(let mk_Piece(a, s):Piece = ret in
  (let mk_(startA, storeA):Free3 = free4 in
    (let mk_(startB, storeB):Free3 = free4~ in
      (not (startB = nil) =>
        pre_min({startB, a})))))

Proof Obligation 49: (Unproved)
DISPOSE4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 119:41
(let mk_Piece(a, s):Piece = ret in
  (let mk_(startA, storeA):Free3 = free4 in
    (let mk_(startB, storeB):Free3 = free4~ in
      (not (startB = nil) =>
        (is_nat(startB))
        and 
        and is_({startB, a}, set of (nat))))))

Proof Obligation 50: (Unproved)
DISPOSE4: function apply obligation in 'Heap4' (./Heap4.vdmsl) at line 120:34
(let mk_Piece(a, s):Piece = ret in
  (let mk_(startA, storeA):Free3 = free4 in
    (let mk_(startB, storeB):Free3 = free4~ in
      ((startA = (if (startB = nil)
      then a
      else min({startB, a}))) =>
        pre_insert4(nil, startB, storeB, a, s)))))

Proof Obligation 51: (Unproved)
DISPOSE4: subtype obligation in 'Heap4' (./Heap4.vdmsl) at line 120:66
(let mk_Piece(a, s):Piece = ret in
  (let mk_(startA, storeA):Free3 = free4 in
    (let mk_(startB, storeB):Free3 = free4~ in
      ((startA = (if (startB = nil)
      then a
      else min({startB, a}))) =>
        s > 0))))

Proof Obligation 52: (Unproved)
DISPOSE4: operation post condition obligation in 'Heap4' (./Heap4.vdmsl) at line 108:5
let mk_Piece(a, s):Piece = ret in let mk_(startA, storeA):Free3 = free4 in let mk_(startB, storeB):Free3 = free4~ in ((startA = (if (startB = nil)
then a
else min({startB, a}))) and (storeA = insert4(nil, startB, storeB, a, s)))

Proof Obligation 53: (Unproved)
DISPOSE4: operation satifiability obligation in 'Heap4' (./Heap4.vdmsl) at line 108:5
(forall ret:Piece, oldstate:StateName &
  pre_DISPOSE4(ret, oldstate) =>
  post_DISPOSE4(ret, oldstate, newstate))

Proof Obligation 54: (Unproved)
retr3_0: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 22:35
(forall mk_(start, store):Free3 &
  pre_locs3(start, store))

Proof Obligation 55: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 30:13
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (({a, (a + 1)} subset (dom store)) =>
      a in set dom store)))

Proof Obligation 56: (Unproved)
isOk3: subtype obligation in 'Heap3' (./Heap3.vdmsl) at line 30:19
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (({a, (a + 1)} subset (dom store)) =>
      ((((is_nat(a))))))))

Proof Obligation 57: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 31:13
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (({a, (a + 1)} subset (dom store)) =>
      ((store(a) <> nil) =>
        a in set dom store))))

Proof Obligation 58: (Unproved)
isOk3: subtype obligation in 'Heap3' (./Heap3.vdmsl) at line 31:19
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (({a, (a + 1)} subset (dom store)) =>
      ((store(a) <> nil) =>
        ((((is_nat(a)))))))))

Proof Obligation 59: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 32:13
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (({a, (a + 1)} subset (dom store)) =>
      ((store(a) <> nil) =>
        ((store(a) > 1) =>
          (a + 1) in set dom store)))))

Proof Obligation 60: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 32:38
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    a in set dom store))

Proof Obligation 61: (Unproved)
isOk3: subtype obligation in 'Heap3' (./Heap3.vdmsl) at line 32:44
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    ((((is_nat(a)))))))

Proof Obligation 62: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 32:49
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (a + 1) in set dom store))

Proof Obligation 63: (Unproved)
isOk3: recursive function obligation in 'Heap3' (./Heap3.vdmsl) at line 24:5
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (((a + store(a)) < store((a + 1))) =>
      measure_LocStore(a, store) > measure_LocStore(store((a + 1)), store))))

Proof Obligation 64: (Unproved)
isOk3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 33:41
(forall a:[Loc], store:Store &
  (not (a = nil) =>
    (((a + store(a)) < store((a + 1))) =>
      (a + 1) in set dom store)))

Proof Obligation 65: (Unproved)
locs3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 41:32
(forall start:[Loc], store:Store & isOk3(start, store) =>
  (not (start = nil) =>
    (start + 1) in set dom store))

Proof Obligation 66: (Unproved)
locs3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 41:56
(forall start:[Loc], store:Store & isOk3(start, store) =>
  (not (start = nil) =>
    pre_locs3(store((start + 1)), store)))

Proof Obligation 67: (Unproved)
locs3: recursive function obligation in 'Heap3' (./Heap3.vdmsl) at line 36:5
(forall start:[Loc], store:Store & isOk3(start, store) =>
  (not (start = nil) =>
    measure_LocStore(start, store) > measure_LocStore(store((start + 1)), store)))

Proof Obligation 68: (Unproved)
locs3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 41:62
(forall start:[Loc], store:Store & isOk3(start, store) =>
  (not (start = nil) =>
    (start + 1) in set dom store))

Proof Obligation 69: (Unproved)
locs3: subtype obligation in 'Heap3' (./Heap3.vdmsl) at line 36:5
(forall start:[Loc], store:Store & isOk3(start, store) =>
  is_((if (start = nil)
  then {}
  else ({start, ... ,((start + store((start + 1))) - 1)} union locs3(store((start + 1)), store))), set of (Loc)))

Proof Obligation 70: (Unproved)
isReachable3: recursive function obligation in 'Heap3' (./Heap3.vdmsl) at line 45:5
(forall a:Loc, start:[Loc], store:Store &
  (not (start = nil) =>
    (not (a = start) =>
      measure_LocLocStore(a, start, store) > measure_LocLocStore(a, store((start + 1)), store))))

Proof Obligation 71: (Unproved)
isReachable3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 52:29
(forall a:Loc, start:[Loc], store:Store &
  (not (start = nil) =>
    (not (a = start) =>
      (start + 1) in set dom store)))

Proof Obligation 72: (Unproved)
nonFreeLocEquiv: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 57:43
(forall startB:[Loc], storeB:Store, storeA:Store &
  pre_locs3(startB, storeB))

Proof Obligation 73: (Trivial by <x in set s => x in set s>)
nonFreeLocEquiv: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 58:39
(forall startB:[Loc], storeB:Store, storeA:Store &
  (forall loc in set ((dom storeB) \ locs3(startB, storeB)) &
    ((loc in set (dom storeA)) =>
      loc in set dom storeA)))

Proof Obligation 74: (Unproved)
nonFreeLocEquiv: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 58:53
(forall startB:[Loc], storeB:Store, storeA:Store &
  (forall loc in set ((dom storeB) \ locs3(startB, storeB)) &
    ((loc in set (dom storeA)) =>
      loc in set dom storeB)))

Proof Obligation 75: (Unproved)
NEW3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 84:21
((req > 1) =>
  (let mk_(start, store):Free3 = free3 in
    (forall a in set (dom store) &
      a in set dom store)))

Proof Obligation 76: (Unproved)
NEW3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 85:22
((req > 1) =>
  (let mk_(start, store):Free3 = free3 in
    (forall a in set (dom store) &
      ((store(a) <> nil) =>
        a in set dom store))))

Proof Obligation 77: (Unproved)
NEW3: map apply obligation in 'Heap3' (./Heap3.vdmsl) at line 85:40
((req > 1) =>
  (let mk_(start, store):Free3 = free3 in
    (forall a in set (dom store) &
      ((store(a) <> nil) =>
        (not (store(a) = req) =>
          a in set dom store)))))

Proof Obligation 78: (Unproved)
NEW3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 89:17
(((res.SIZE) = req) =>
  (let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in
    pre_locs3(startA, storeA)))

Proof Obligation 79: (Unproved)
NEW3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 89:41
(((res.SIZE) = req) =>
  (let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in
    pre_locs3(startB, storeB)))

Proof Obligation 80: (Unproved)
NEW3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 90:42
(((res.SIZE) = req) =>
  (let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in
    ((locs3(startA, storeA) = (locs3(startB, storeB) \ Heap1locs_of(res))) =>
      pre_locs3(startB, storeB))))

Proof Obligation 81: (Unproved)
NEW3: operation post condition obligation in 'Heap3' (./Heap3.vdmsl) at line 79:5
(((res.SIZE) = req) and let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in ((locs3(startA, storeA) = (locs3(startB, storeB) \ Heap1locs_of(res))) and ((Heap1locs_of(res) subset locs3(startB, storeB)) and nonFreeLocEquiv(startB, storeB, storeA))))

Proof Obligation 82: (Unproved)
NEW3: operation satifiability obligation in 'Heap3' (./Heap3.vdmsl) at line 79:5
(forall req:nat, oldstate:StateName &
  pre_NEW3(req, oldstate) =>
  exists res:Piece, newstate:StateName & post_NEW3(req, res, oldstate, newstate))

Proof Obligation 83: (Unproved)
DISPOSE3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 97:41
(((ret.SIZE) > 1) =>
  (let mk_(start, store):Free3 = free3 in
    pre_locs3(start, store)))

Proof Obligation 84: (Unproved)
DISPOSE3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 99:17
(let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in
  pre_locs3(startA, storeA))

Proof Obligation 85: (Unproved)
DISPOSE3: function apply obligation in 'Heap3' (./Heap3.vdmsl) at line 99:41
(let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in
  pre_locs3(startB, storeB))

Proof Obligation 86: (Unproved)
DISPOSE3: operation post condition obligation in 'Heap3' (./Heap3.vdmsl) at line 93:5
let mk_(startA, storeA):Free3 = free3, mk_(startB, storeB):Free3 = free3~ in ((locs3(startA, storeA) = (locs3(startB, storeB) union Heap1locs_of(ret))) and nonFreeLocEquiv(startB, storeB, storeA))

Proof Obligation 87: (Unproved)
DISPOSE3: operation satifiability obligation in 'Heap3' (./Heap3.vdmsl) at line 93:5
(forall ret:Piece, oldstate:StateName &
  pre_DISPOSE3(ret, oldstate) =>
  post_DISPOSE3(ret, oldstate, newstate))

Proof Obligation 88: (Unproved)
ALL_FP: finite set obligation in 'Heap2' (./Heap2.vdmsl) at line 27:26
exists finmap1:map nat to (Fp) &
  forall fp:Fp &
    exists findex2 in set dom finmap1 & finmap1(findex2) = fp

Proof Obligation 89: (Unproved)
isOk2: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 30:5
(forall fp:Free2 &
  (not (fp = nil) =>
    (not ((fp.FPNEXT) = nil) =>
      ((((fp.FPLOC) + (fp.FPSIZE)) < ((fp.FPNEXT).FPLOC)) =>
        measure_Free2(fp) > measure_Free2((fp.FPNEXT))))))

Proof Obligation 90: (Unproved)
locs2: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 39:5
(forall fp:Free2 &
  (not (fp = nil) =>
    measure_Free2(fp) > measure_Free2((fp.FPNEXT))))

Proof Obligation 91: (Unproved)
locs2: subtype obligation in 'Heap2' (./Heap2.vdmsl) at line 39:5
(forall fp:Free2 &
  is_((if (fp = nil)
  then {}
  else ({(fp.FPLOC), ... ,(((fp.FPLOC) + (fp.FPSIZE)) - 1)} union locs2((fp.FPNEXT)))), set of (Loc)))

Proof Obligation 92: (Unproved)
isReachable: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 46:5
(forall fp:Fp, start:Free2 &
  (not (start = nil) =>
    (not (fp = start) =>
      measure_fpFree2(fp, start) > measure_fpFree2(fp, (start.FPNEXT)))))

Proof Obligation 93: (Unproved)
retr2_1: subtype obligation in 'Heap2' (./Heap2.vdmsl) at line 58:5
(forall free:Free2 &
  (inv_Free1({mk_Piece((fp.FPLOC), (fp.FPSIZE)) | [fp in set ALL_FP] & isReachable(fp, free)}) and (is_({mk_Piece((fp.FPLOC), (fp.FPSIZE)) | [fp in set ALL_FP] & isReachable(fp, free)}, set of (Piece)))))

Proof Obligation 94: (Unproved)
split: function satisfiability obligation in 'Heap2' (./Heap2.vdmsl) at line 63:5
(forall ps:Free1 &
  pre_split(ps) => exists r:(Piece * Free1) & post_split(ps, r))

Proof Obligation 95: (Unproved)
inv_retr2_1, p, s: function apply obligation in 'Heap2' (./Heap2.vdmsl) at line 74:45
(forall ps:Free1 &
  (not (ps = {}) =>
    pre_split(ps)))

Proof Obligation 96: (Unproved)
inv_retr2_1: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 70:5
(forall ps:Free1 &
  (not (ps = {}) =>
    (let mk_(p, s):(Piece * Free1) = split(ps) in
      measure_Free1(ps) > measure_Free1(s))))

Proof Obligation 97: (Unproved)
measure_Free2: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 81:5
(forall fp:Free2 &
  (not ((fp = nil) or ((fp.FPNEXT) = nil)) =>
    measure_unk(fp) > measure_unk((fp.FPNEXT))))

Proof Obligation 98: (Unproved)
measure_unk: subtype obligation in 'Heap2' (./Heap2.vdmsl) at line 85:5
(forall fp:Free2 &
  is_nat(measure_unk(fp)))

Proof Obligation 99: (Unproved)
measure_fpFree2: recursive function obligation in 'Heap2' (./Heap2.vdmsl) at line 88:5
(forall fp:Fp, f2:Free2 &
  (not ((f2 = nil) or (fp = f2)) =>
    measure_unk2(fp, f2) > measure_unk2(fp, (f2.FPNEXT))))

Proof Obligation 100: (Unproved)
measure_unk2: subtype obligation in 'Heap2' (./Heap2.vdmsl) at line 92:5
(forall fp:Fp, f2:Free2 &
  is_nat(measure_unk2(fp, f2)))

Proof Obligation 101: (Unproved)
NEW2: operation post condition obligation in 'Heap2' (./Heap2.vdmsl) at line 100:5
((locs2(free2) = (locs2(free2~) \ Heap1locs_of(res))) and ((Heap1locs_of(res) subset locs2(free2~)) and ((res.SIZE) = req)))

Proof Obligation 102: (Unproved)
NEW2: operation satifiability obligation in 'Heap2' (./Heap2.vdmsl) at line 100:5
(forall req:nat, oldstate:Heap2St &
  pre_NEW2(req, oldstate) =>
  exists res:Piece, newstate:Heap2St & post_NEW2(req, res, oldstate, newstate))

Proof Obligation 103: (Unproved)
DISPOSE2: operation post condition obligation in 'Heap2' (./Heap2.vdmsl) at line 107:5
(locs2(free2) = (locs2(free2~) union Heap1locs_of(ret)))

Proof Obligation 104: (Unproved)
DISPOSE2: operation satifiability obligation in 'Heap2' (./Heap2.vdmsl) at line 107:5
(forall ret:Piece, oldstate:Heap2St &
  pre_DISPOSE2(ret, oldstate) =>
  post_DISPOSE2(ret, oldstate, newstate))

Proof Obligation 105: (Unproved)
locs_of: subtype obligation in 'Heap1' (./Heap1.vdmsl) at line 23:5
(forall p:Piece &
  (((is_nat((((p.LOC) + (p.SIZE)) - 1)))))
  and is_({(p.LOC), ... ,(((p.LOC) + (p.SIZE)) - 1)}, set of (Loc)))

Proof Obligation 106: (Unproved)
NEW1: operation post condition obligation in 'Heap1' (./Heap1.vdmsl) at line 37:5
((locs(free1) = (locs(free1~) \ locs_of(res))) and ((locs_of(res) subset locs(free1~)) and ((res.SIZE) = req)))

Proof Obligation 107: (Unproved)
NEW1: operation satifiability obligation in 'Heap1' (./Heap1.vdmsl) at line 37:5
(forall req:nat, oldstate:Heap1St &
  pre_NEW1(req, oldstate) =>
  exists res:Piece, newstate:Heap1St & post_NEW1(req, res, oldstate, newstate))

Proof Obligation 108: (Unproved)
DISPOSE1: operation post condition obligation in 'Heap1' (./Heap1.vdmsl) at line 44:5
(locs(free1) = (locs(free1~) union locs_of(ret)))

Proof Obligation 109: (Unproved)
DISPOSE1: operation satifiability obligation in 'Heap1' (./Heap1.vdmsl) at line 44:5
(forall ret:Piece, oldstate:Heap1St &
  pre_DISPOSE1(ret, oldstate) =>
  post_DISPOSE1(ret, oldstate, newstate))

Proof Obligation 110: (Unproved)
ALL_LOCS: subtype obligation in 'Heap0' (./Heap0.vdmsl) at line 13:23
(is_({0, ... ,10}, set of (Loc)))

Proof Obligation 111: (Unproved)
ALL_LOCSEQ: finite set obligation in 'Heap0' (./Heap0.vdmsl) at line 14:37
exists finmap1:map nat to (seq of (Loc)) &
  forall i:seq of (Loc) &
    exists findex2 in set dom finmap1 & finmap1(findex2) = i

Proof Obligation 112: (Unproved)
NEW0: operation post condition obligation in 'Heap0' (./Heap0.vdmsl) at line 35:1
(exists [s in set ALL_LOCSEQ] & (has_seq(s, req, free0~) and ((res = (elems s)) and (free0 = (free0~ \ res)))))

Proof Obligation 113: (Unproved)
NEW0: operation satifiability obligation in 'Heap0' (./Heap0.vdmsl) at line 35:1
(forall req:nat, oldstate:Heap0St &
  pre_NEW0(req, oldstate) =>
  exists res:set of (Loc), newstate:Heap0St & post_NEW0(req, res, oldstate, newstate))

Proof Obligation 114: (Unproved)
DISPOSE0: operation post condition obligation in 'Heap0' (./Heap0.vdmsl) at line 43:1
(free0 = (free0~ union ret))

Proof Obligation 115: (Unproved)
DISPOSE0: operation satifiability obligation in 'Heap0' (./Heap0.vdmsl) at line 43:1
(forall ret:Free0, oldstate:Heap0St &
  pre_DISPOSE0(ret, oldstate) =>
  post_DISPOSE0(ret, oldstate, newstate))

Proof Obligation 116: (Unproved)
writeval: subtype obligation in 'IO' (./lib/IO.vdmsl) at line 40:1
(forall val:@p &
  is_(writeval(val), bool))

Proof Obligation 117: (Unproved)
fwriteval: subtype obligation in 'IO' (./lib/IO.vdmsl) at line 54:1
(forall filename:seq1 of (char), val:@p, fdir:filedirective &
  is_(fwriteval(filename, val, fdir), bool))

Proof Obligation 118: (Unproved)
freadval: post condition obligation in 'IO' (./lib/IO.vdmsl) at line 66:1
(forall filename:seq1 of (char) &
  post_freadval(filename, freadval(filename)))

Proof Obligation 119: (Unproved)
freadval: subtype obligation in 'IO' (./lib/IO.vdmsl) at line 66:1
(forall filename:seq1 of (char) &
  is_(freadval(filename), (bool * [@p])))

Proof Obligation 120: (Unproved)
set2seq: subtype obligation in 'VDMUtil' (./lib/VDMUtil.vdmsl) at line 18:1
(forall x:set of (@T) &
  is_(set2seq(x), seq of (@T)))

Proof Obligation 121: (Unproved)
get_file_pos: subtype obligation in 'VDMUtil' (./lib/VDMUtil.vdmsl) at line 23:1
is_(get_file_pos(), [(seq of (char) * nat * nat * seq of (char) * seq of (char))])

Proof Obligation 122: (Unproved)
val2seq_of_char: subtype obligation in 'VDMUtil' (./lib/VDMUtil.vdmsl) at line 27:1
(forall x:@T &
  is_(val2seq_of_char(x), seq of (char)))

Proof Obligation 123: (Unproved)
seq_of_char2val: post condition obligation in 'VDMUtil' (./lib/VDMUtil.vdmsl) at line 32:1
(forall s:seq1 of (char) &
  post_seq_of_char2val(s, seq_of_char2val(s)))

Proof Obligation 124: (Unproved)
seq_of_char2val: subtype obligation in 'VDMUtil' (./lib/VDMUtil.vdmsl) at line 32:1
(forall s:seq1 of (char) &
  is_(seq_of_char2val(s), (bool * [@p])))

