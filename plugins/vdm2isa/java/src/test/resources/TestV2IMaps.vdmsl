module TestV2IMaps
exports all
definitions

types
	--TCRecordType,TCField,TCFieldList
	R :: 
		x: nat 
		y: nat	
	inv r == r.x < r.y;
	
values
	t9 : set1 of nat1 = {1,2,3};					--TCSetType
	v65: R = mk_R(1,2);

	v74= (lambda var : nat, var2: nat & var + var2); --TCLambdaExpression + TCMultipleTypeBind
	v741=(lambda mk_R(x,y): R & x + y); --!!! Phew....
	v80= (let x, y in set t9 be st x > 2 and y < x in x + y); --TCLetBeStExpression
	v801=(let mk_R(x,y) in set {v65} be st x < y in x+y);
	v95= { x |-> 10 | x in set {1,2,3} }; --TCMapCompExpression 
	v952={ x+y |-> 10 | x in set {1,2,3}, y in set {4,5,6} }; --TCMapCompExpression harder ones
	v953={ mk_R(x,y) |-> 10 | x in set {1,2,3}, y in set {4,5,6} };
	v954= { x + y |-> 10 | [x,y] in set {[1,2], [3,4], [4,5]} }; -- this is getting silly now
	
	v97 = { x |-> 10 | x in set {1,2,3}, y in set {4,5,6} };
	v98: map nat to nat1 = { d |-> r | d in set {1,2,3}, r in set {2,4,6} & r = d*2 };
functions
	v96: () -> map nat to nat
	v96() == { x |-> 10 | x: nat & x < 10 };

	v961: () -> map nat to nat
	v961() == { x+y |-> 10 | x: nat, y in set {4,5,6} & x < 10 };

end TestV2IMaps